using System;
using System.Text;
using SpanJson;
using JsonConvert = Newtonsoft.Json.JsonConvert;

namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class binance : ccxt.binance
{
    public virtual PreparedMessage CreateOrderPrepareMessageWs(object parameters = null)
    {
        PreparedMessage preparedMessage;

        object requestIdPlaceHolder = "%REQUEST_ID_PLACE_HOLDER%";
        object messageHashPlaceHolder = "%MESSAGE_HASH_PLACE_HOLDER%";
        object symbolPlaceHolder = "%SYMBOL_PLACE_HOLDER%";
        object typePlaceHolder = "%TYPE_PLACE_HOLDER%"; 
        object sidePlaceHolder = "%SIDE_PLACE_HOLDER%"; 
        object amountPlaceHolder = "%AMOUNT_PLACE_HOLDER%"; 
        object pricePlaceHolder = "%PRICE_PLACE_HOLDER%"; 
        

        #region CREATE ORDER ****************************** this part of code is from createOrder method ****************************** //
        parameters ??= new Dictionary<string, object>();
        this.loadMarkets().Wait();
        object market = this.market(symbolPlaceHolder);
        object marketType = this.getMarketType("createOrderWs", market, parameters);
        if (isTrue(isTrue(!isEqual(marketType, "spot")) && isTrue(!isEqual(marketType, "future"))))
        {
            throw new BadRequest ((string)add(this.id, " createOrderWs only supports spot or swap markets")) ;
        }
        object url = getValue(getValue(getValue(getValue(this.urls, "api"), "ws"), "ws-api"), marketType);
        object sor = this.safeBool2(parameters, "sor", "SOR", false);
        parameters = this.omit(parameters, "sor", "SOR");
        object payload = this.createOrderRequest(symbolPlaceHolder, typePlaceHolder, sidePlaceHolder, amountPlaceHolder, pricePlaceHolder, parameters);
        object returnRateLimits = false;
        var returnRateLimitsparametersVariable = this.handleOptionAndParams(parameters, "createOrderWs", "returnRateLimits", false);
        returnRateLimits = ((IList<object>)returnRateLimitsparametersVariable)[0];
        parameters = ((IList<object>)returnRateLimitsparametersVariable)[1];
        ((IDictionary<string,object>)payload)["returnRateLimits"] = returnRateLimits;
        object test = this.safeBool(parameters, "test", false);
        parameters = this.omit(parameters, "test");
        object message = new Dictionary<string, object>() {
            { "id", messageHashPlaceHolder },
            { "method", "order.place" },
            { "params", this.signParams(this.extend(payload, parameters)) },
        };
        if (isTrue(test))
        {
            if (isTrue(sor))
            {
                ((IDictionary<string,object>)message)["method"] = "sor.order.test";
            } else
            {
                ((IDictionary<string,object>)message)["method"] = "order.test";
            }
        }
        var subscription = new Dictionary<string, object>() {
            { "method", this.handleOrderWs },
        };
        #endregion

        preparedMessage = new PreparedMessage(
            client: this.client(url),
            exchange: this,
            url: (string)url,
            bytesMessage: Encoding.UTF8.GetBytes( JsonSerializer.Generic.Utf16.Serialize(message)),
            placeholderObjectDict: new Dictionary<string, object>() {
                { "messageHash", messageHashPlaceHolder },
                { "symbol", symbolPlaceHolder },
                { "type", typePlaceHolder },
                { "side", sidePlaceHolder },
                { "amount", amountPlaceHolder },
                { "price", pricePlaceHolder },
                { "parameters", parameters },
            },
            subscription: subscription
        );

        return preparedMessage;
        // await this.watch(url, messageHash, message, messageHash, subscription);
    }
}
